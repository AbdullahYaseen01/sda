"""
scan_and_detect.py - Real-time product detection using ORB matching

This script provides continuous product scanning from webcam. You can scan multiple
times, adding products to a persistent cart. Each scan detects up to 10 products.
Only products with reference images are added to the cart. When you quit, a receipt
is automatically generated, saved, and printed.

Requirements:
    pip install opencv-contrib-python numpy pandas

Usage:
    python scan_and_detect.py

Controls:
    - Press Enter: Capture frame and scan for products (max 10 per scan)
    - Press 'c': Continue without capturing (skip this frame)
    - Press 'q': Quit and generate receipt

Required files:
    - refs_orb.pkl (generated by precompute_refs.py)
    - products.csv (format: id,name,category,price or price_excl_vat)
    - product_images/ directory

Output:
    - receipt/receipt_YYYYMMDD_HHMMSS.html (HTML receipt with detected items)
    - Receipt is automatically printed to default printer
"""

import cv2
import pickle
import numpy as np
import pandas as pd
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Tuple, Optional

# ============================================================================
# TUNING CONSTANTS
# ============================================================================
MIN_GOOD_MATCHES = 12        # Minimum number of good matches to consider a detection
MAX_PROPOSALS = 100          # Maximum number of region proposals (reduced for faster scanning)
ORB_NFEATURES = 1500         # Number of ORB features (should match precompute_refs.py)
DIST_THRESHOLD = 35          # Maximum distance for a good match
NMS_IOU_THRESHOLD = 0.4      # IoU threshold for Non-Maximum Suppression
MAX_DETECTIONS = 10          # Maximum number of final detections
MIN_BOX_SIZE = 40            # Minimum width/height for region proposals
VAT_RATE = 0.20              # VAT rate (20%)
MIN_SCORE_RATIO = 1.3        # Best match must be at least 1.3x better than second best
MIN_ABSOLUTE_SCORE = 15      # Minimum absolute score to accept a detection
DEBUG_MODE = False           # Show detailed detection scores for debugging

# File paths
REFS_FILE = "refs_orb.pkl"
PRODUCTS_CSV = "products.csv"
RECEIPT_DIR = "receipt"  # Changed to singular


class ProductDetector:
    """Main class for product detection."""
    
    def __init__(self):
        """Initialize detector with references and products."""
        self.orb = cv2.ORB_create(nfeatures=ORB_NFEATURES)
        self.matcher = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
        self.refs_data = None
        self.products_df = None
        self.name_to_id_map = {}  # Map product name to ID
        self.load_references()
        self.load_products()
    
    def load_references(self):
        """Load precomputed ORB references from pickle file."""
        print(f"Loading references from '{REFS_FILE}'...")
        try:
            with open(REFS_FILE, 'rb') as f:
                self.refs_data = pickle.load(f)
            
            # Note: Keypoints are stored but not needed for matching (only descriptors are used)
            # We keep the kp data in the pickle for completeness but don't reconstruct KeyPoint objects
            
            print(f"Loaded references for {len(self.refs_data)} products")
        except FileNotFoundError:
            print(f"Error: '{REFS_FILE}' not found! Run precompute_refs.py first.")
            raise
        except Exception as e:
            print(f"Error loading references: {e}")
            raise
    
    def load_products(self):
        """Load product information from CSV."""
        print(f"Loading products from '{PRODUCTS_CSV}'...")
        try:
            # Try different encodings
            try:
                self.products_df = pd.read_csv(PRODUCTS_CSV, encoding='utf-8')
            except UnicodeDecodeError:
                try:
                    self.products_df = pd.read_csv(PRODUCTS_CSV, encoding='latin-1')
                except:
                    self.products_df = pd.read_csv(PRODUCTS_CSV, encoding='cp1252')
            # Ensure required columns exist
            # Check for price column (support both 'price' and 'price_excl_vat')
            required_cols = ['id', 'name', 'category']
            if not all(col in self.products_df.columns for col in required_cols):
                raise ValueError(f"CSV must contain columns: {required_cols}")
            
            # Handle price column (support both 'price' and 'price_excl_vat')
            if 'price_excl_vat' in self.products_df.columns:
                price_col = 'price_excl_vat'
            elif 'price' in self.products_df.columns:
                price_col = 'price'
            else:
                raise ValueError("CSV must contain either 'price' or 'price_excl_vat' column")
            
            # Convert price to float and store in 'price' column for consistency
            self.products_df['price'] = pd.to_numeric(self.products_df[price_col], errors='coerce')
            
            # Create mapping from product name to ID (since folder names match product names)
            self.name_to_id_map = {}
            for _, row in self.products_df.iterrows():
                self.name_to_id_map[row['name']] = row['id']
            
            print(f"Loaded {len(self.products_df)} products")
        except FileNotFoundError:
            print(f"Error: '{PRODUCTS_CSV}' not found!")
            raise
        except Exception as e:
            print(f"Error loading products: {e}")
            raise
    
    def get_region_proposals(self, image):
        """
        Generate region proposals using Selective Search.
        Returns list of (x, y, w, h) bounding boxes.
        """
        ss = cv2.ximgproc.segmentation.createSelectiveSearchSegmentation()
        ss.setBaseImage(image)
        ss.switchToSelectiveSearchFast()  # Fast mode for speed
        
        # Get proposals
        proposals = ss.process()
        
        # Filter by minimum size and limit count
        filtered_proposals = []
        for proposal in proposals:
            x, y, w, h = proposal
            if w >= MIN_BOX_SIZE and h >= MIN_BOX_SIZE:
                filtered_proposals.append(proposal)
        
        # Limit to MAX_PROPOSALS
        filtered_proposals = filtered_proposals[:MAX_PROPOSALS]
        
        return filtered_proposals
    
    def compute_roi_descriptors(self, image, bbox):
        """Compute ORB descriptors for a region of interest."""
        x, y, w, h = bbox
        roi = image[y:y+h, x:x+w]
        
        if roi.size == 0:
            return None, None
        
        gray_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
        keypoints, descriptors = self.orb.detectAndCompute(gray_roi, None)
        
        return keypoints, descriptors
    
    def match_descriptors(self, query_descriptors, ref_descriptors):
        """
        Match query descriptors to reference descriptors.
        Returns number of good matches (distance < DIST_THRESHOLD).
        """
        if query_descriptors is None or ref_descriptors is None:
            return 0
        
        if len(query_descriptors) == 0 or len(ref_descriptors) == 0:
            return 0
        
        try:
            matches = self.matcher.match(query_descriptors, ref_descriptors)
            good_matches = [m for m in matches if m.distance < DIST_THRESHOLD]
            return len(good_matches)
        except:
            return 0
    
    def detect_in_region(self, image, bbox):
        """
        Detect product in a region proposal.
        Returns (product_id, score) or (None, 0) if no match.
        Uses ratio test to ensure best match is significantly better than others.
        """
        # Compute descriptors for ROI
        _, roi_descriptors = self.compute_roi_descriptors(image, bbox)
        
        if roi_descriptors is None:
            return None, 0
        
        # Store scores for all products
        product_scores = {}
        
        # Match against all reference products
        for product_id, refs in self.refs_data.items():
            total_matches = 0
            
            for ref in refs:
                ref_descriptors = ref["des"]
                matches = self.match_descriptors(roi_descriptors, ref_descriptors)
                total_matches += matches
            
            # Average matches per reference image
            avg_matches = total_matches / len(refs) if refs else 0
            product_scores[product_id] = avg_matches
        
        # Find best and second best matches
        if len(product_scores) == 0:
            return None, 0
        
        # Sort by score (descending)
        sorted_scores = sorted(product_scores.items(), key=lambda x: x[1], reverse=True)
        
        if len(sorted_scores) == 0:
            return None, 0
        
        best_product_id, best_score = sorted_scores[0]
        
        # Debug output (only for regions that might match)
        if DEBUG_MODE and best_score >= 8:  # Only show if there's some potential match
            top_3 = sorted_scores[:3]
            top_products = ", ".join([f"{pid}({score:.1f})" for pid, score in top_3])
            if len(sorted_scores) > 1:
                second_best_score = sorted_scores[1][1]
                ratio = best_score / second_best_score if second_best_score > 0 else float('inf')
                print(f"    Region match scores: {top_products} | Ratio: {ratio:.2f}")
        
        # Must meet minimum absolute score threshold
        if best_score < MIN_ABSOLUTE_SCORE:
            if DEBUG_MODE:
                print(f"  Rejected {best_product_id}: score {best_score:.1f} < MIN_ABSOLUTE_SCORE ({MIN_ABSOLUTE_SCORE})")
            return None, 0
        
        # Must also meet minimum good matches threshold
        if best_score < MIN_GOOD_MATCHES:
            if DEBUG_MODE:
                print(f"  Rejected {best_product_id}: score {best_score:.1f} < MIN_GOOD_MATCHES ({MIN_GOOD_MATCHES})")
            return None, 0
        
        # If there's a second best, apply ratio test (but more lenient)
        if len(sorted_scores) > 1:
            second_best_score = sorted_scores[1][1]
            # Best match must be significantly better than second best
            if second_best_score > 0:
                ratio = best_score / second_best_score if second_best_score > 0 else float('inf')
                if ratio < MIN_SCORE_RATIO:
                    # Best match is not significantly better - likely false positive
                    if DEBUG_MODE:
                        print(f"  Rejected {best_product_id}: ratio {ratio:.2f} < MIN_SCORE_RATIO ({MIN_SCORE_RATIO})")
                    return None, 0
                # Also check: if second best is too close (within 5 matches), reject
                if best_score - second_best_score < 5:
                    if DEBUG_MODE:
                        print(f"  Rejected {best_product_id}: score difference {best_score - second_best_score:.1f} < 5")
                    return None, 0
        
        if DEBUG_MODE:
            print(f"  Accepted: {best_product_id} with score {best_score:.1f}")
        
        return best_product_id, best_score
    
    def non_max_suppression(self, boxes, scores, iou_threshold=NMS_IOU_THRESHOLD):
        """
        Apply Non-Maximum Suppression to filter overlapping detections.
        Returns indices of boxes to keep.
        """
        if len(boxes) == 0:
            return []
        
        # Convert to format expected by NMSBoxes: (x, y, w, h)
        boxes_np = np.array(boxes, dtype=np.float32)
        scores_np = np.array(scores, dtype=np.float32)
        
        # Apply NMS
        indices = cv2.dnn.NMSBoxes(
            boxes_np.tolist(),
            scores_np.tolist(),
            score_threshold=0.0,
            nms_threshold=iou_threshold
        )
        
        if len(indices) == 0:
            return []
        
        # Return as list of integers
        return [int(i) for i in indices.flatten()]
    
    def detect_products(self, image):
        """
        Main detection function.
        Returns list of detections: [(product_id, bbox, score), ...]
        """
        proposals = self.get_region_proposals(image)
        
        detections = []
        
        # Process proposals (faster - no progress updates)
        for bbox in proposals:
            product_id, score = self.detect_in_region(image, bbox)
            
            if product_id is not None:
                detections.append((product_id, bbox, score))
        
        if len(detections) > 0:
            print(f"Found {len(detections)} initial detections")
        
        if len(detections) == 0:
            return []
        
        # Apply NMS (silent for speed)
        boxes = [det[1] for det in detections]
        scores = [det[2] for det in detections]
        
        nms_indices = self.non_max_suppression(boxes, scores)
        
        # Filter and limit detections
        final_detections = [detections[i] for i in nms_indices]
        final_detections = sorted(final_detections, key=lambda x: x[2], reverse=True)
        final_detections = final_detections[:MAX_DETECTIONS]
        
        # Prevent detecting one product as multiple different products
        # If we have multiple different products, only keep the one with highest score
        # unless all products have very high scores (indicating multiple real products)
        if len(final_detections) > 1:
            # Group by product name
            products_detected = {}
            for product_name, bbox, score in final_detections:
                if product_name not in products_detected:
                    products_detected[product_name] = []
                products_detected[product_name].append((product_name, bbox, score))
            
            # If we detected multiple different products
            if len(products_detected) > 1:
                # Get the best score for each product
                best_scores = {name: max([d[2] for d in dets]) for name, dets in products_detected.items()}
                sorted_products = sorted(best_scores.items(), key=lambda x: x[1], reverse=True)
                
                best_product_name, best_score = sorted_products[0]
                second_best_score = sorted_products[1][1] if len(sorted_products) > 1 else 0
                
                # If best product score is significantly higher, only keep that product
                # This prevents false positives where one product is detected correctly
                # but another product is incorrectly detected
                if best_score > second_best_score * 1.5 and best_score >= MIN_ABSOLUTE_SCORE:
                    print(f"Multiple products detected, but '{best_product_name}' has significantly higher score ({best_score:.1f} vs {second_best_score:.1f}).")
                    print(f"Keeping only '{best_product_name}' to prevent false positives.")
                    # Keep only detections of the best product
                    final_detections = [d for d in final_detections if d[0] == best_product_name]
                # If scores are close, require both to be reasonably high to accept multiple products
                elif best_score < MIN_ABSOLUTE_SCORE * 1.2:
                    # Scores are not high enough to confidently detect multiple products
                    print(f"Multiple products detected but scores are not high enough (best: {best_score:.1f}).")
                    print(f"Keeping only the best match: '{best_product_name}'")
                    final_detections = [d for d in final_detections if d[0] == best_product_name]
                else:
                    # Both products have reasonable scores - allow both (might be multiple products in view)
                    print(f"Multiple products detected with good scores - keeping all: {list(products_detected.keys())}")
        
        print(f"Final detections after NMS and validation: {len(final_detections)}")
        
        return final_detections
    
    def filter_detections_with_references(self, detections):
        """
        Filter detections to only include products that have reference images.
        Returns filtered list of detections.
        """
        filtered = []
        for product_name, bbox, score in detections:
            # Only keep products that exist in refs_data (have reference images)
            if product_name in self.refs_data:
                filtered.append((product_name, bbox, score))
            else:
                print(f"  Skipping '{product_name}' - no reference images available")
        
        return filtered
    
    def build_cart_from_detections(self, detections):
        """
        Build shopping cart items from detections.
        Returns list of cart items with quantities.
        Note: Each unique product in a scan gets quantity 1.
        If the same product appears multiple times in one scan, it still counts as quantity 1.
        Quantity increases only when the same product is scanned again in a later scan.
        """
        # Filter to only products with reference images
        valid_detections = self.filter_detections_with_references(detections)
        
        if len(valid_detections) == 0:
            return []
        
        # Get unique products from this scan (one scan = quantity 1 per product)
        # If same product appears multiple times in one scan, it's still quantity 1
        unique_products = set()
        for product_name, _, _ in valid_detections:
            unique_products.add(product_name)
        
        # Build cart items - each unique product gets quantity 1
        cart_items = []
        for product_name in unique_products:
            # Convert product name to ID using mapping
            product_id = self.name_to_id_map.get(product_name)
            
            if product_id is None:
                print(f"Warning: Product name '{product_name}' not found in products.csv")
                continue
            
            # Get product info from DataFrame
            product_info = self.products_df[self.products_df['id'] == product_id]
            
            if len(product_info) == 0:
                print(f"Warning: Product ID '{product_id}' not found in products.csv")
                continue
            
            row = product_info.iloc[0]
            cart_items.append({
                'id': product_id,
                'name': row['name'],
                'category': row['category'],
                'unit_price': float(row['price']),
                'qty': 1,  # One scan = quantity 1
                'subtotal': float(row['price']) * 1
            })
        
        return cart_items
    
    def merge_cart_items(self, existing_cart, new_items):
        """
        Merge new cart items into existing cart, combining quantities for same products.
        Returns updated cart list.
        """
        # Create a dict for quick lookup: product_id -> cart_item
        cart_dict = {item['id']: item.copy() for item in existing_cart}
        
        # Add new items
        for new_item in new_items:
            product_id = new_item['id']
            if product_id in cart_dict:
                # Update quantity and subtotal
                cart_dict[product_id]['qty'] += new_item['qty']
                cart_dict[product_id]['subtotal'] = cart_dict[product_id]['unit_price'] * cart_dict[product_id]['qty']
            else:
                # Add new product
                cart_dict[product_id] = new_item.copy()
        
        # Return as list
        return list(cart_dict.values())
    
    def calculate_totals(self, cart):
        """Calculate cart totals including VAT."""
        total_excl_vat = sum(item['subtotal'] for item in cart)
        vat_amount = total_excl_vat * VAT_RATE
        total_incl_vat = total_excl_vat + vat_amount
        
        return {
            'total_excl_vat': total_excl_vat,
            'vat_amount': vat_amount,
            'total_incl_vat': total_incl_vat
        }
    
    def save_receipt(self, cart, totals):
        """Save HTML receipt to file and return path."""
        # Ensure receipt directory exists
        Path(RECEIPT_DIR).mkdir(exist_ok=True)
        
        # Generate filename with timestamp
        timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
        receipt_filename = f"receipt_{timestamp_str}.html"
        receipt_path = Path(RECEIPT_DIR) / receipt_filename
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Check if logo exists and copy to receipt directory if needed
        logo_path = None
        receipt_logo_path = Path(RECEIPT_DIR) / "LOGO.jpeg"
        
        # Try to find logo in various locations
        possible_logo_sources = [
            Path("LOGO.jpeg"),
            Path("receipts/LOGO.jpeg"),
            Path(RECEIPT_DIR) / "LOGO.jpeg"
        ]
        
        for source_path in possible_logo_sources:
            if source_path.exists():
                # Copy to receipt directory if not already there
                if not receipt_logo_path.exists() or source_path != receipt_logo_path:
                    try:
                        import shutil
                        shutil.copy2(source_path, receipt_logo_path)
                    except:
                        pass
                logo_path = "LOGO.jpeg"  # Relative path from receipt file
                break
        
        # Build logo HTML (avoiding backslash in f-string)
        logo_html = ""
        if logo_path:
            onerror_attr = "this.style.display='none'"
            logo_html = f'<img src="{logo_path}" alt="Logo" class="logo" onerror="{onerror_attr}">'
        
        html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Receipt</title>
    <style>
        @media print {{
            .no-print {{
                display: none !important;
            }}
            body {{
                margin: 0;
                padding: 10px;
            }}
            .receipt-container {{
                margin: 0;
                padding: 15px;
                box-shadow: none;
            }}
        }}
        body {{
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: white;
        }}
        .receipt-container {{
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            background: white;
        }}
        .header {{
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }}
        .logo {{
            max-width: 80px;
            max-height: 80px;
            margin: 0 auto 10px;
            display: block;
        }}
        .receipt-info {{
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 0.9em;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 0.9em;
        }}
        th {{
            padding: 8px 5px;
            text-align: left;
            border-bottom: 1px solid #333;
            font-weight: bold;
        }}
        th:last-child, td:last-child {{
            text-align: right;
        }}
        td {{
            padding: 6px 5px;
            border-bottom: 1px solid #ddd;
        }}
        .totals {{
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #333;
        }}
        .total-line {{
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }}
        .total-final {{
            font-weight: bold;
            font-size: 1.1em;
            margin-top: 5px;
            padding-top: 8px;
            border-top: 1px solid #333;
        }}
        .footer {{
            text-align: center;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
            font-size: 0.85em;
            color: #666;
        }}
        .print-button {{
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #333;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 0.9em;
            cursor: pointer;
            z-index: 1000;
        }}
        .print-button:hover {{
            background: #555;
        }}
    </style>
</head>
<body>
    <div class="receipt-container">
        <div class="header">
            {logo_html}
            <div>Receipt #{timestamp_str}</div>
            <div style="font-size: 0.85em; color: #666; margin-top: 5px;">{timestamp}</div>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th>Product</th>
                    <th>Price</th>
                    <th>Qty</th>
                    <th>Total</th>
                </tr>
            </thead>
            <tbody>
"""
        
        for item in cart:
            html_content += f"""                <tr>
                    <td>{item['name']}</td>
                    <td>€{item['unit_price']:.2f}</td>
                    <td>{item['qty']}</td>
                    <td>€{item['subtotal']:.2f}</td>
                </tr>
"""
        
        html_content += f"""            </tbody>
        </table>
        
        <div class="totals">
            <div class="total-line">
                <span>Subtotal:</span>
                <span>€{totals['total_excl_vat']:.2f}</span>
            </div>
            <div class="total-line">
                <span>VAT (20%):</span>
                <span>€{totals['vat_amount']:.2f}</span>
            </div>
            <div class="total-line total-final">
                <span>Total:</span>
                <span>€{totals['total_incl_vat']:.2f}</span>
            </div>
        </div>
        
        <div class="footer">
            <p>Thank you for your purchase!</p>
        </div>
    </div>
    
    <button class="print-button no-print" onclick="window.print()">
        Print / PDF
    </button>
</body>
</html>"""
        
        try:
            with open(receipt_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            print(f"\nReceipt saved to: {receipt_path}")
            return receipt_path
        except Exception as e:
            print(f"Error saving receipt: {e}")
            return None
    
    def draw_detections(self, image, detections):
        """Draw detections on image for visualization."""
        result_image = image.copy()
        
        # Group detections by product name to avoid duplicate labels
        # Keep only the detection with highest score for each product
        product_detections = {}
        for product_name, bbox, score in detections:
            if product_name not in product_detections or score > product_detections[product_name][2]:
                product_detections[product_name] = (product_name, bbox, score)
        
        # Draw each unique product only once
        for product_name, bbox, score in product_detections.values():
            x, y, w, h = bbox
            
            # Get product ID and name for label
            product_id = self.name_to_id_map.get(product_name, '?')
            product_info = self.products_df[self.products_df['name'] == product_name]
            if len(product_info) > 0:
                label = f"{product_id}: {product_name} ({score:.1f})"
            else:
                label = f"{product_name} ({score:.1f})"
            
            # Draw rectangle
            cv2.rectangle(result_image, (x, y), (x + w, y + h), (0, 255, 0), 2)
            
            # Draw label background
            (text_width, text_height), _ = cv2.getTextSize(
                label, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2
            )
            cv2.rectangle(
                result_image,
                (x, y - text_height - 10),
                (x + text_width, y),
                (0, 255, 0),
                -1
            )
            
            # Draw label text
            cv2.putText(
                result_image,
                label,
                (x, y - 5),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.6,
                (0, 0, 0),
                2
            )
        
        return result_image


def capture_frame_from_webcam(cap, cart_item_count=0, current_cart=None):
    """
    Capture a single frame from already-opened webcam.
    Returns frame or special string codes.
    current_cart: list of cart items to display on screen
    """
    # Build instruction text
    instructions = [
        "Enter: Scan | 'q': Close Cart & Print | ESC: Exit Camera",
        f"Cart: {cart_item_count} item(s)"
    ]
    
    while True:
        ret, frame = cap.read()
        if not ret:
            print("Error: Could not read frame from webcam!")
            return None
        
        # Draw instructions on frame
        y_offset = 30
        for i, text in enumerate(instructions):
            cv2.putText(frame, text, (10, y_offset + i * 30), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        
        # Draw current cart items on frame (product names)
        if current_cart and len(current_cart) > 0:
            cart_y = y_offset + len(instructions) * 30 + 10
            cv2.putText(frame, "Cart Items:", (10, cart_y), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)
            for idx, item in enumerate(current_cart[:5]):  # Show max 5 items
                item_text = f"  {item['name']} x{item['qty']}"
                cv2.putText(frame, item_text, (10, cart_y + (idx + 1) * 25), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 1)
            if len(current_cart) > 5:
                cv2.putText(frame, f"  ... and {len(current_cart) - 5} more", 
                           (10, cart_y + 6 * 25), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 1)
        
        cv2.imshow("Product Scanner", frame)
        
        key = cv2.waitKey(1) & 0xFF
        if key == ord('\r') or key == ord('\n'):  # Enter key
            print("Frame captured!")
            return frame
        elif key == ord('q'):
            print("Closing cart and printing receipt...")
            return 'print_cart'  # Changed: 'q' now prints cart instead of quitting
        elif key == 27:  # Escape key (ASCII 27)
            print("Exiting camera...")
            return 'quit'  # Escape quits the application
        elif key == ord('c'):
            print("Skipping this frame...")
            return 'skip'
    
    return None


def print_cart(cart, totals, show_header=True):
    """Print cart contents and totals to console."""
    if show_header:
        print("\n" + "=" * 80)
        print("SHOPPING CART")
        print("=" * 80)
    else:
        print("\n" + "-" * 80)
        print("UPDATED CART")
        print("-" * 80)
    
    if len(cart) == 0:
        print("Cart is empty.")
        print("=" * 80)
        return
    
    print(f"{'ID':<10} {'Name':<30} {'Category':<15} {'Price':<10} {'Qty':<5} {'Subtotal':<10}")
    print("-" * 80)
    
    for item in cart:
        print(f"{item['id']:<10} {item['name']:<30} {item['category']:<15} "
              f"€{item['unit_price']:<9.2f} {item['qty']:<5} €{item['subtotal']:<9.2f}")
    
    print("-" * 80)
    print(f"{'Subtotal (excl. VAT):':<60} €{totals['total_excl_vat']:.2f}")
    print(f"{'VAT (20%):':<60} €{totals['vat_amount']:.2f}")
    print(f"{'Total (incl. VAT):':<60} €{totals['total_incl_vat']:.2f}")
    print("=" * 80)


def print_receipt(receipt_path):
    """Open receipt in browser for printing."""
    import webbrowser
    import sys
    import os
    from pathlib import Path
    
    if receipt_path is None or not receipt_path.exists():
        print("Cannot print: receipt file not found.")
        return False
    
    try:
        # Convert to absolute path
        abs_path = Path(receipt_path).resolve()
        
        # Open in default browser
        if sys.platform == 'win32':
            # On Windows, try os.startfile first (more reliable)
            try:
                os.startfile(str(abs_path))
                print(f"Receipt opened in default browser.")
                print(f"Press Ctrl+P to print, or use the browser's print button.")
            except:
                # Fallback to webbrowser
                file_url = f'file:///{abs_path}'
                webbrowser.open(file_url)
                print(f"Receipt opened in browser.")
                print(f"Press Ctrl+P to print, or use the browser's print button.")
        else:
            # On Linux/Mac, use webbrowser
            file_url = f'file://{abs_path}'
            webbrowser.open(file_url)
            print(f"Receipt opened in browser.")
            print(f"Press Ctrl+P (Cmd+P on Mac) to print, or use the browser's print button.")
        
        return True
    except Exception as e:
        print(f"Could not open receipt automatically: {e}")
        print(f"Please manually open {receipt_path} in a browser and print (Ctrl+P).")
        return False


def main():
    """Main function with continuous scanning loop."""
    print("=" * 80)
    print("Product Detection System - Continuous Scanning Mode")
    print("=" * 80)
    
    # Initialize webcam
    print("\nInitializing webcam...")
    cap = cv2.VideoCapture(0)
    
    if not cap.isOpened():
        print("Error: Could not open webcam!")
        print("Please ensure a webcam is connected and not being used by another application.")
        return
    
    print("Webcam opened successfully.")
    
    try:
        # Initialize detector
        detector = ProductDetector()
        
        # Initialize persistent cart
        cart = []
        scan_count = 0
        
        print("\n" + "=" * 80)
        print("INSTRUCTIONS:")
        print("  - Press Enter: Scan products and add to cart")
        print("  - Press 'q': Close current cart, print receipt, and start new cart")
        print("  - Press ESC: Exit camera and close application")
        print("=" * 80)
        print("\nCamera will stay open. Start scanning products!")
        
        customer_number = 1
        
        # Main scanning loop - continues until 'q' is pressed
        while True:
            # Initialize cart for current customer
            cart = []
            scan_count = 0
            
            print("\n" + "=" * 80)
            print(f"CUSTOMER #{customer_number} - New Cart Started")
            print("=" * 80)
            
            # Customer-specific scanning loop
            while True:
                scan_count += 1
                print(f"\n--- Scan #{scan_count} (Customer #{customer_number}) ---")
                
                # Get cart item count for display
                cart_item_count = len(cart)
                
                # Capture frame (pass current cart to show on screen)
                frame = capture_frame_from_webcam(cap, cart_item_count, cart)
                
                # Check return value (can be numpy array, string, or None)
                if isinstance(frame, str):
                    if frame == 'quit':
                        # ESC pressed - exit application
                        # Generate receipt for current cart if not empty
                        if len(cart) > 0:
                            print("\n" + "=" * 80)
                            print("GENERATING FINAL RECEIPT")
                            print("=" * 80)
                            totals = detector.calculate_totals(cart)
                            print_cart(cart, totals, show_header=True)
                            receipt_path = detector.save_receipt(cart, totals)
                            if receipt_path:
                                print_receipt(receipt_path)
                        print("\nShutting down...")
                        return
                    elif frame == 'print_cart':
                        # 'q' pressed - close cart, print receipt, start new cart
                        break  # Break out of customer loop to print and start new cart
                    elif frame == 'skip':
                        continue
                elif frame is None:
                    continue
                
                # Detect products (fast mode - 3-4 seconds)
                print("Scanning...")
                detections = detector.detect_products(frame)
                
                if len(detections) == 0:
                    print("No products detected.")
                    continue
                
                # Filter to only products with reference images
                valid_detections = detector.filter_detections_with_references(detections)
                
                if len(valid_detections) == 0:
                    print("No valid products detected.")
                    continue
                
                # Show what products were detected
                detected_products = {}
                for product_name, bbox, score in valid_detections:
                    if product_name not in detected_products:
                        detected_products[product_name] = {'count': 0, 'max_score': 0}
                    detected_products[product_name]['count'] += 1
                    detected_products[product_name]['max_score'] = max(detected_products[product_name]['max_score'], score)
                
                print(f"Detected: {', '.join(detected_products.keys())}")
                
                # Build cart items from this scan
                new_cart_items = detector.build_cart_from_detections(valid_detections)
                
                if len(new_cart_items) == 0:
                    continue
                
                # Merge with existing cart (this increases quantity if product already exists)
                cart = detector.merge_cart_items(cart, new_cart_items)
                
                # Calculate totals
                totals = detector.calculate_totals(cart)
                
                # Show updated cart summary
                print(f"Cart updated: {len(cart)} item(s), Total: €{totals['total_incl_vat']:.2f}")
                
                # Show detection visualization briefly (2 seconds)
                result_image = detector.draw_detections(frame, valid_detections)
                cv2.imshow("Detections", result_image)
                cv2.waitKey(2000)  # Show for 2 seconds
                cv2.destroyAllWindows()
            
            # User pressed 'p' - print cart and start new customer
            print("\n" + "=" * 80)
            print(f"GENERATING RECEIPT FOR CUSTOMER #{customer_number}")
            print("=" * 80)
            
            if len(cart) == 0:
                print("Cart is empty. No receipt generated.")
            else:
                # Calculate final totals
                totals = detector.calculate_totals(cart)
                
                # Print final cart
                print_cart(cart, totals, show_header=True)
                
                # Save receipt
                receipt_path = detector.save_receipt(cart, totals)
                
                # Print receipt
                if receipt_path:
                    print("\nPrinting receipt...")
                    print_receipt(receipt_path)
                
                print(f"\nReceipt generated for Customer #{customer_number}!")
                print("Starting new cart for next customer...")
            
            # Increment customer number for next customer
            customer_number += 1
        
    except KeyboardInterrupt:
        print("\n\nInterrupted by user.")
        # Still generate receipt if cart has items
        if len(cart) > 0:
            print("Generating receipt from current cart...")
            totals = detector.calculate_totals(cart)
            receipt_path = detector.save_receipt(cart, totals)
            if receipt_path:
                print_receipt(receipt_path)
    except Exception as e:
        print(f"\nError: {e}")
        import traceback
        traceback.print_exc()
    finally:
        # Clean up
        cap.release()
        cv2.destroyAllWindows()
        print("\nWebcam released. Goodbye!")


if __name__ == "__main__":
    main()

