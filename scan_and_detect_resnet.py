"""
scan_and_detect_resnet.py - Real-time product detection using ResNet50 features

This script provides continuous product scanning from webcam using deep learning
feature matching. You can scan multiple times, adding products to a persistent cart.
Each scan detects up to 10 products. Only products with reference images are added
to the cart. When you quit, a receipt is automatically generated, saved, and printed.

Uses ResNet50 (pre-trained on ImageNet) for robust feature extraction that works
well with limited training data (5 images per product).

Requirements:
    pip install torch torchvision opencv-python numpy pandas pillow

Usage:
    python scan_and_detect_resnet.py

Controls:
    - Press Enter: Capture frame and scan for products (max 10 per scan)
    - Press 'c': Continue without capturing (skip this frame)
    - Press 'q': Quit and generate receipt

Required files:
    - refs_resnet.pkl (generated by precompute_refs_resnet.py)
    - products.csv (format: id,name,category,price or price_excl_vat)

Output:
    - receipt/receipt_YYYYMMDD_HHMMSS.html (HTML receipt with detected items)
    - Receipt is automatically printed to default printer
"""

import cv2
import pickle
import numpy as np
import pandas as pd
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Tuple, Optional
import torch
import torch.nn as nn
from torchvision import models, transforms
from PIL import Image
import io

# ============================================================================
# TUNING CONSTANTS
# ============================================================================
MIN_SIMILARITY_SCORE = 0.80   # Cosine similarity threshold (0-1, higher = stricter)
MAX_PROPOSALS = 50            # Maximum number of region proposals (reduced for speed)
NMS_IOU_THRESHOLD = 0.4       # IoU threshold for Non-Maximum Suppression
MAX_DETECTIONS = 10           # Maximum number of final detections
MIN_BOX_SIZE = 40             # Minimum width/height for region proposals
VAT_RATE = 0.20               # VAT rate (20%)
DEBUG_MODE = False            # Show detailed detection scores for debugging
RESIZE_SCALE = 0.5            # Resize frame to 50% for faster processing (NEW)

# Device
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# File paths
REFS_FILE = "refs_resnet.pkl"
PRODUCTS_CSV = "products.csv"
RECEIPT_DIR = "receipt"


class ProductDetector:
    """Main class for product detection using ResNet50 features."""
    
    def __init__(self):
        """Initialize detector with references and products."""
        self.device = DEVICE
        self.refs_data = None
        self.products_df = None
        self.name_to_id_map = {}
        
        # Initialize ResNet50 feature extractor
        self.feature_extractor = self._load_feature_extractor()
        
        # Image preprocessing transform
        self.transform = transforms.Compose([
            transforms.Resize(256),
            transforms.CenterCrop(224),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406],
                               std=[0.229, 0.224, 0.225]),
        ])
        
        self.load_references()
        self.load_products()
    
    def _load_feature_extractor(self) -> nn.Module:
        """Load pre-trained ResNet50 as feature extractor."""
        print("Loading pre-trained ResNet50...")
        model = models.resnet50(weights=models.ResNet50_Weights.IMAGENET1K_V2)
        
        # Remove classification head to get features
        feature_extractor = nn.Sequential(*list(model.children())[:-1])
        feature_extractor.to(self.device)
        feature_extractor.eval()
        
        return feature_extractor
    
    def load_references(self):
        """Load precomputed ResNet50 features from pickle file."""
        print(f"Loading references from '{REFS_FILE}'...")
        try:
            with open(REFS_FILE, 'rb') as f:
                self.refs_data = pickle.load(f)
            
            print(f"Loaded references for {len(self.refs_data)} products")
        except FileNotFoundError:
            print(f"Error: '{REFS_FILE}' not found! Run precompute_refs_resnet.py first.")
            raise
        except Exception as e:
            print(f"Error loading references: {e}")
            raise
    
    def load_products(self):
        """Load product information from CSV."""
        print(f"Loading products from '{PRODUCTS_CSV}'...")
        try:
            # Try different encodings
            try:
                self.products_df = pd.read_csv(PRODUCTS_CSV, encoding='utf-8')
            except UnicodeDecodeError:
                try:
                    self.products_df = pd.read_csv(PRODUCTS_CSV, encoding='latin-1')
                except:
                    self.products_df = pd.read_csv(PRODUCTS_CSV, encoding='cp1252')
            
            # Ensure required columns exist
            if 'id' not in self.products_df.columns:
                print("Warning: 'id' column not found in products.csv")
            if 'name' not in self.products_df.columns:
                print("Warning: 'name' column not found in products.csv")
            if 'price' not in self.products_df.columns and 'price_excl_vat' not in self.products_df.columns:
                print("Warning: 'price' or 'price_excl_vat' column not found in products.csv")
            
            # Create mapping from product name to ID
            for idx, row in self.products_df.iterrows():
                if 'name' in row and 'id' in row:
                    self.name_to_id_map[row['name']] = row['id']
            
            print(f"Loaded {len(self.products_df)} products")
        except FileNotFoundError:
            print(f"Error: '{PRODUCTS_CSV}' not found!")
            raise
        except Exception as e:
            print(f"Error loading products: {e}")
            raise
    
    def extract_features(self, image_array: np.ndarray) -> np.ndarray:
        """Extract ResNet50 features from a numpy image array (BGR from OpenCV)."""
        try:
            # Convert BGR to RGB
            image_rgb = cv2.cvtColor(image_array, cv2.COLOR_BGR2RGB)
            
            # Convert to PIL Image
            pil_image = Image.fromarray(image_rgb)
            
            # Apply transforms
            img_tensor = self.transform(pil_image).unsqueeze(0).to(self.device)
            
            # Extract features
            with torch.no_grad():
                features = self.feature_extractor(img_tensor)
            
            # Convert to numpy and flatten
            features = features.squeeze().cpu().numpy()
            
            # Normalize to unit length for cosine similarity
            features = features / (np.linalg.norm(features) + 1e-8)
            
            return features
        except Exception as e:
            if DEBUG_MODE:
                print(f"Error extracting features: {e}")
            return None
    
    def compute_similarity(self, features1: np.ndarray, features2: np.ndarray) -> float:
        """Compute cosine similarity between two feature vectors."""
        # Both should be normalized, so dot product = cosine similarity
        similarity = np.dot(features1, features2)
        return float(similarity)
    
    def detect_products_in_frame(self, frame: np.ndarray) -> List[Dict]:
        """
        Detect products in the frame using region proposals and feature matching.
        Returns list of detected products with confidence scores.
        """
        # Resize frame for faster processing (optional, improves speed 3-5x)
        if RESIZE_SCALE < 1.0:
            frame = cv2.resize(frame, None, fx=RESIZE_SCALE, fy=RESIZE_SCALE)
        
        height, width = frame.shape[:2]
        detections = []
        
        # Generate region proposals (simple sliding window approach)
        proposals = self._generate_proposals(frame, width, height)
        
        for proposal in proposals:
            x1, y1, x2, y2, score = proposal
            
            # Skip if region is too small
            if x2 - x1 < MIN_BOX_SIZE or y2 - y1 < MIN_BOX_SIZE:
                continue
            
            # Extract region
            region = frame[y1:y2, x1:x2]
            
            # Extract features from region
            region_features = self.extract_features(region)
            if region_features is None:
                continue
            
            # Find best matching product
            best_match = None
            best_score = MIN_SIMILARITY_SCORE
            
            for product_name, product_images in self.refs_data.items():
                # Compare with all reference images for this product
                for ref_image_data in product_images:
                    ref_features = ref_image_data['features']
                    
                    # Compute similarity
                    similarity = self.compute_similarity(region_features, ref_features)
                    
                    if similarity > best_score:
                        best_score = similarity
                        best_match = product_name
            
            if best_match is not None:
                detections.append({
                    'product_name': best_match,
                    'box': (x1, y1, x2, y2),
                    'score': best_score
                })
        
        # Apply Non-Maximum Suppression
        detections = self._nms(detections)
        
        # Keep only top MAX_DETECTIONS
        detections = sorted(detections, key=lambda x: x['score'], reverse=True)[:MAX_DETECTIONS]
        
        return detections
    
    def _generate_proposals(self, frame: np.ndarray, width: int, height: int) -> List[Tuple]:
        """Generate region proposals (optimized for real-time)."""
        proposals = []
        
        # Reduced scales for faster processing
        scales = [0.5, 0.65, 0.8]  # Reduced from 7 to 3 scales
        stride = 64  # Larger stride to skip more regions
        
        for scale in scales:
            box_size = int(224 * scale)  # ResNet input size
            
            if box_size < MIN_BOX_SIZE:
                continue
            
            # Sliding window
            for y in range(0, height - box_size + 1, stride):
                for x in range(0, width - box_size + 1, stride):
                    x1, y1 = x, y
                    x2, y2 = min(x + box_size, width), min(y + box_size, height)
                    
                    # Dummy score (can be replaced with saliency detection)
                    score = 1.0
                    proposals.append((x1, y1, x2, y2, score))
                    
                    if len(proposals) >= MAX_PROPOSALS:
                        return proposals
        
        return proposals
    
    def _nms(self, detections: List[Dict]) -> List[Dict]:
        """Apply Non-Maximum Suppression to remove overlapping detections."""
        if not detections:
            return detections
        
        # Sort by score
        detections = sorted(detections, key=lambda x: x['score'], reverse=True)
        
        keep = []
        for i, det in enumerate(detections):
            if i == 0:
                keep.append(det)
                continue
            
            # Check overlap with kept detections
            keep_this = True
            x1_i, y1_i, x2_i, y2_i = det['box']
            
            for kept_det in keep:
                x1_j, y1_j, x2_j, y2_j = kept_det['box']
                
                # Compute IoU
                inter_x1 = max(x1_i, x1_j)
                inter_y1 = max(y1_i, y1_j)
                inter_x2 = min(x2_i, x2_j)
                inter_y2 = min(y2_i, y2_j)
                
                if inter_x2 > inter_x1 and inter_y2 > inter_y1:
                    inter_area = (inter_x2 - inter_x1) * (inter_y2 - inter_y1)
                    area_i = (x2_i - x1_i) * (y2_i - y1_i)
                    area_j = (x2_j - x1_j) * (y2_j - y1_j)
                    union_area = area_i + area_j - inter_area
                    iou = inter_area / union_area
                    
                    if iou > NMS_IOU_THRESHOLD:
                        keep_this = False
                        break
            
            if keep_this:
                keep.append(det)
        
        return keep
    
    def get_product_info(self, product_name: str) -> Optional[Dict]:
        """Get product information from CSV by product name."""
        matches = self.products_df[self.products_df['name'] == product_name]
        
        if not matches.empty:
            return matches.iloc[0].to_dict()
        
        return None


class Cart:
    """Shopping cart for storing detected products."""
    
    def __init__(self):
        """Initialize empty cart."""
        self.items = []
    
    def add_item(self, product_info: Dict):
        """Add item to cart."""
        # Check if product already in cart
        for item in self.items:
            if item['name'] == product_info['name']:
                item['quantity'] += 1
                return
        
        # Add as new item
        product_info['quantity'] = 1
        self.items.append(product_info)
    
    def get_total(self) -> float:
        """Calculate total price."""
        total = 0
        for item in self.items:
            price = item.get('price', item.get('price_excl_vat', 0))
            total += float(price) * item['quantity']
        return total
    
    def get_total_with_vat(self) -> float:
        """Calculate total with VAT."""
        total = self.get_total()
        return total * (1 + VAT_RATE)
    
    def get_vat(self) -> float:
        """Calculate VAT amount."""
        return self.get_total_with_vat() - self.get_total()


def generate_receipt_html(cart: Cart, timestamp: datetime) -> str:
    """Generate HTML receipt."""
    html = """
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Receipt</title>
        <style>
            body { font-family: Arial, sans-serif; max-width: 500px; margin: 20px auto; }
            table { width: 100%; border-collapse: collapse; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background-color: #4CAF50; color: white; }
            .total { font-weight: bold; font-size: 16px; }
            .header { text-align: center; margin-bottom: 20px; }
            .footer { text-align: center; margin-top: 20px; font-size: 12px; }
        </style>
    </head>
    <body>
        <div class="header">
            <h2>Receipt</h2>
            <p>{}</p>
        </div>
        <table>
            <tr>
                <th>Product</th>
                <th>Qty</th>
                <th>Unit Price</th>
                <th>Total</th>
            </tr>
    """.format(timestamp.strftime('%Y-%m-%d %H:%M:%S'))
    
    for item in cart.items:
        price = item.get('price', item.get('price_excl_vat', 0))
        total = float(price) * item['quantity']
        html += f"""
            <tr>
                <td>{item.get('name', 'Unknown')}</td>
                <td>{item['quantity']}</td>
                <td>${price:.2f}</td>
                <td>${total:.2f}</td>
            </tr>
        """
    
    html += f"""
        </table>
        <table style="margin-top: 20px;">
            <tr>
                <td>Subtotal:</td>
                <td class="total">${cart.get_total():.2f}</td>
            </tr>
            <tr>
                <td>VAT ({VAT_RATE*100:.0f}%):</td>
                <td class="total">${cart.get_vat():.2f}</td>
            </tr>
            <tr style="font-size: 18px;">
                <td>Total:</td>
                <td class="total">${cart.get_total_with_vat():.2f}</td>
            </tr>
        </table>
        <div class="footer">
            <p>Thank you for your purchase!</p>
        </div>
    </body>
    </html>
    """
    
    return html


def save_receipt(html_content: str, receipt_dir: str) -> str:
    """Save receipt to HTML file and return file path."""
    Path(receipt_dir).mkdir(exist_ok=True)
    
    timestamp = datetime.now()
    filename = f"receipt_{timestamp.strftime('%Y%m%d_%H%M%S')}.html"
    filepath = Path(receipt_dir) / filename
    
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    return str(filepath)


def print_receipt(html_path: str):
    """Print receipt to default printer."""
    try:
        import subprocess
        import sys
        
        if sys.platform == 'win32':
            # Windows
            subprocess.Popen(['notepad', '/p', html_path])
        elif sys.platform == 'darwin':
            # macOS
            subprocess.Popen(['lpr', html_path])
        else:
            # Linux
            subprocess.Popen(['lpr', html_path])
    except Exception as e:
        print(f"Could not print receipt: {e}")


def main():
    """Main function for real-time product scanning."""
    print("=" * 70)
    print("Product Detection System - ResNet50 Feature Matching")
    print("=" * 70)
    
    # Initialize detector and cart
    detector = ProductDetector()
    cart = Cart()
    
    print("\nInitializing webcam...")
    cap = cv2.VideoCapture(0)
    
    if not cap.isOpened():
        print("Error: Could not open webcam")
        return
    
    print("\n" + "=" * 70)
    print("Controls:")
    print("  - Press ENTER: Capture and scan for products")
    print("  - Press 'c': Continue to next frame")
    print("  - Press 'q': Quit and generate receipt")
    print("=" * 70 + "\n")
    
    while True:
        ret, frame = cap.read()
        
        if not ret:
            print("Error: Could not read frame")
            break
        
        # Display frame
        cv2.imshow('Product Scanner', frame)
        
        # Wait for user input
        key = cv2.waitKey(1) & 0xFF
        
        if key == 13:  # Enter key
            print("\nScanning frame...")
            
            # Detect products
            detections = detector.detect_products_in_frame(frame)
            
            if detections:
                print(f"Detected {len(detections)} products:")
                for det in detections:
                    product_info = detector.get_product_info(det['product_name'])
                    if product_info:
                        print(f"  - {det['product_name']} (confidence: {det['score']:.3f})")
                        cart.add_item(product_info)
                    else:
                        print(f"  - {det['product_name']} (NO PRICE INFO)")
            else:
                print("No products detected")
            
            print(f"Cart items: {len(cart.items)}")
        
        elif key == ord('c'):
            print("Continuing...")
        
        elif key == ord('q'):
            print("\nGenerating receipt...")
            break
    
    cap.release()
    cv2.destroyAllWindows()
    
    # Generate and save receipt
    if cart.items:
        print(f"\nReceipt Summary:")
        print(f"Items: {len(cart.items)}")
        print(f"Total: ${cart.get_total_with_vat():.2f}")
        
        html_content = generate_receipt_html(cart, datetime.now())
        receipt_path = save_receipt(html_content, RECEIPT_DIR)
        
        print(f"Receipt saved to: {receipt_path}")
        
        # Try to print
        try:
            print_receipt(receipt_path)
        except:
            pass
    else:
        print("Cart is empty. No receipt generated.")


if __name__ == "__main__":
    main()
